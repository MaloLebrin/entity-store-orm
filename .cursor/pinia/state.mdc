# State

Master this and much more with the official video course by the author of Pinia.

The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.

✨ Vibe code Vue apps with confidence

## 🚀 Basic State Definition

```typescript
import { defineStore } from 'pinia'

export const useStore = defineStore('storeId', {
  // arrow function recommended for full type inference
  state: () => {
    return {
      // all these properties will have their type inferred automatically
      count: 0,
      name: 'Eduardo',
      isAdmin: true,
      items: [],
      hasChanged: true,
    }
  },
})
```

### ⚠️ TIP

In order for Vue to properly detect state, you must declare every state piece in state, even if its initial value is undefined.

## 🔧 TypeScript Support

You don't need to do much in order to make your state compatible with TS: make sure `strict`, or at the very least, `noImplicitThis`, is enabled and Pinia will infer the type of your state automatically! However, there are a few cases where you should give it a hand with some casting:

### Type casting for empty collections

```typescript
export const useUserStore = defineStore('user', {
  state: () => {
    return {
      // for initially empty lists
      userList: [] as UserInfo[],
      // for data that is not yet loaded
      user: null as UserInfo | null,
    }
  },
})

interface UserInfo {
  name: string
  age: number
}
```

### Interface-based state definition

If you prefer, you can define the state with an interface and type the return value of `state()`:

```typescript
interface State {
  userList: UserInfo[]
  user: UserInfo | null
}

export const useUserStore = defineStore('user', {
  state: (): State => {
    return {
      userList: [],
      user: null,
    }
  },
})

interface UserInfo {
  name: string
  age: number
}
```

## 📖 Accessing the State

By default, you can directly read from and write to the state by accessing it through the store instance:

```typescript
const store = useStore()

store.count++
```

Yes, this means no verbose wrappers like in Vuex, you can directly bind that to `v-model`:

```vue
<input v-model="store.count" type="number" />
```

### ⚠️ INFO

You cannot add a new state property if you don't define it in `state()`. It must contain the initial state. e.g.: we can't do `store.secondCount = 2` if `secondCount` is not defined in `state()`.

## 🔄 Resetting the State

### Option Stores

In Option Stores, you can reset the state to its initial value by calling the `$reset()` method on the store:

```typescript
const store = useStore()

store.$reset()
```

Internally, this calls the `state()` function to create a new state object and replaces the current state with it.

### Setup Stores

In Setup Stores, you need to create your own `$reset()` method:

```typescript
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)

  function $reset() {
    count.value = 0
  }

  return { count, $reset }
})
```

## 🎯 Usage with the Options API

Watch a free video lesson on Vue School.

For the following examples, you can assume the following store was created:

```typescript
// Example File Path:
// ./src/stores/counter.js

import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
  }),
})
```

### Mapping state as computed properties

If you are not using the Composition API, and you are using `computed`, `methods`, ..., you can use the `mapState()` helper to map state properties as readonly computed properties:

```typescript
import { mapState } from 'pinia'
import { useCounterStore } from '../stores/counter'

export default {
  computed: {
    // gives access to this.count inside the component
    // same as reading from store.count
    ...mapState(useCounterStore, ['count']),
    
    // same as above but registers it as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'count',
      // you can also write a function that gets access to the store
      double: store => store.count * 2,
      // it can have access to `this` but it won't be typed correctly...
      magicValue(store) {
        return store.someGetter + this.count + this.double
      },
    }),
  },
}
```

### Modifiable state

If you want to be able to write to these state properties (e.g. if you have a form), you can use `mapWritableState()` instead. Note you cannot pass a function like with `mapState()`:

```typescript
import { mapWritableState } from 'pinia'
import { useCounterStore } from '../stores/counter'

export default {
  computed: {
    // gives access to this.count inside the component and allows setting it
    // this.count++
    // same as reading from store.count
    ...mapWritableState(useCounterStore, ['count']),
    
    // same as above but registers it as this.myOwnName
    ...mapWritableState(useCounterStore, {
      myOwnName: 'count',
    }),
  },
}
```

### ⚠️ TIP

You don't need `mapWritableState()` for collections like arrays unless you are replacing the whole array with `cartItems = []`, `mapState()` still allows you to call methods on your collections.

## 🔧 Mutating the State

Apart from directly mutating the store with `store.count++`, you can also call the `$patch` method. It allows you to apply multiple changes at the same time with a partial state object:

### Object-based patching

```typescript
store.$patch({
  count: store.count + 1,
  age: 120,
  name: 'DIO',
})
```

### Function-based patching

However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the `$patch` method also accepts a function to group these kinds of mutations that are difficult to apply with a patch object:

```typescript
store.$patch((state) => {
  state.items.push({ name: 'shoes', quantity: 1 })
  state.hasChanged = true
})
```

The main difference here is that `$patch()` allows you to group multiple changes into one single entry in the devtools. Note that both direct changes to state and `$patch()` are tracked in devtools and can be time traveled.

## 🔄 Replacing the State

You cannot exactly replace the state of a store as that would break reactivity. You can however patch it:

```typescript
// this doesn't actually replace `$state`
store.$state = { count: 24 }
// it internally calls `$patch()`:
store.$patch({ count: 24 })
```

You can also set the initial state of your whole application by changing the state of the pinia instance. This is used during SSR for hydration:

```typescript
pinia.state.value = {}
```

## 👀 Subscribing to the State

You can watch the state and its changes through the `$subscribe()` method of a store, similar to Vuex's subscribe method. The advantage of using `$subscribe()` over a regular `watch()` is that subscriptions will trigger only once after patches (e.g. when using the function version from above).

### Basic subscription

```typescript
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type // 'direct' | 'patch object' | 'patch function'
  // same as cartStore.$id
  mutation.storeId // 'cart'
  // only available with mutation.type === 'patch object'
  mutation.payload // patch object passed to cartStore.$patch()

  // persist the whole state to the local storage whenever it changes
  localStorage.setItem('cart', JSON.stringify(state))
})
```

### Flush timing

Under the hood, `$subscribe()` uses Vue's `watch()` function. You can pass the same options as you would with `watch()`. This is useful when you want to immediately trigger subscriptions after each state change:

```typescript
cartStore.$subscribe((mutation, state) => {
  // persist the whole state to the local storage whenever it changes
  localStorage.setItem('cart', JSON.stringify(state))
}, { flush: 'sync' })
```

### Detaching subscriptions

By default, state subscriptions are bound to the component where they are added (if the store is inside a component's `setup()`). Meaning, they will be automatically removed when the component is unmounted. If you also want to keep them after the component is unmounted, pass `{ detached: true }` as the second argument to detach the state subscription from the current component:

```vue
<script setup>
const someStore = useSomeStore()

// this subscription will be kept even after the component is unmounted
someStore.$subscribe(callback, { detached: true })
</script>
```

### ⚠️ TIP

You can watch the whole state on the pinia instance with a single `watch()`:

```typescript
watch(
  pinia.state,
  (state) => {
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem('piniaState', JSON.stringify(state))
  },
  { deep: true }
)
```

    localStorage.setItem('piniaState', JSON.stringify(state))
  },
  { deep: true }
)
