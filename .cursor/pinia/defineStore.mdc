# Defining a Store

Master this and much more with a free video from Mastering Pinia.

Before diving into core concepts, we need to know that a store is defined using `defineStore()` and that it requires a unique name, passed as the first argument.

‚ú® Vibe code Vue apps with confidence

## üöÄ Basic Store Definition

```typescript
import { defineStore } from 'pinia'

// You can name the return value of `defineStore()` anything you want,
// but it's best to use the name of the store and surround it with `use`
// and `Store` (e.g. `useUserStore`, `useCartStore`, `useProductStore`)
// the first argument is a unique id of the store across your application
export const useAlertsStore = defineStore('alerts', {
  // other options...
})
```

This name, also referred to as `id`, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function `use...` is a convention across composables to make its usage idiomatic.

`defineStore()` accepts two distinct values for its second argument: a Setup function or an Options object.

## üéØ Option Stores

Similar to Vue's Options API, we can also pass an Options Object with `state`, `actions`, and `getters` properties.

```typescript
export const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0, name: 'Eduardo' }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

You can think of:
- **state** as the data of the store
- **getters** as the computed properties of the store
- **actions** as the methods

Option stores should feel intuitive and simple to get started with.

## üîß Setup Stores

There is also another possible syntax to define stores. Similar to the Vue Composition API's `setup` function, we can pass in a function that defines reactive properties and methods and returns an object with the properties and methods we want to expose.

```typescript
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const name = ref('Eduardo')
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, name, doubleCount, increment }
})
```

### Setup Store Rules

In Setup Stores:
- `ref()`s become state properties
- `computed()`s become getters
- `function()`s become actions

### ‚ö†Ô∏è Important Notes

Note that you must return all state properties in setup stores for Pinia to pick them up as state. In other words, you cannot have private state properties in stores. Not returning all state properties or making them readonly will break SSR, devtools, and other plugins.

Setup stores bring a lot more flexibility than Option Stores as you can create watchers within a store and freely use any composable. However, keep in mind that using composables will get more complex when using SSR.

### Accessing Global Properties

Setup stores are also able to rely on globally provided properties like the Router or the Route. Any property provided at the App level can be accessed from the store using `inject()`, just like in components:

```typescript
import { inject } from 'vue'
import { useRoute } from 'vue-router'
import { defineStore } from 'pinia'

export const useSearchFilters = defineStore('search-filters', () => {
  const route = useRoute()
  // this assumes `app.provide('appProvided', 'value')` was called
  const appProvided = inject('appProvided')

  // ...

  return {
    // ...
  }
})
```

### ‚ö†Ô∏è WARNING

Do not return properties like `route` or `appProvided` (from the example above) as they do not belong to the store itself and you can directly access them within components with `useRoute()` and `inject('appProvided')`.

## ü§î What Syntax Should I Pick?

As with Vue's Composition API and Options API, pick the one that you feel the most comfortable with. Both have their strengths and weaknesses:

- **Options stores** are easier to work with
- **Setup stores** are more flexible and powerful

If you want to dive deeper into the differences, check the Option Stores vs Setup Stores chapter in Mastering Pinia.

## üìñ Using the Store

We are defining a store because the store won't be created until `use...Store()` is called within a component `<script setup>` (or within `setup()` like all composables):

```vue
<script setup>
import { useCounterStore } from '@/stores/counter'

// access the `store` variable anywhere in the component ‚ú®
const store = useCounterStore()
</script>
```

### ‚ö†Ô∏è TIP

If you are not using setup components yet, you can still use Pinia with map helpers.

You can define as many stores as you want and you should define each store in a different file to get the most out of Pinia (like automatically allowing your bundler to code split and providing TypeScript inference).

Once the store is instantiated, you can access any property defined in state, getters, and actions directly on the store. We will look at these in detail in the next pages but autocompletion will help you.

### Reactivity and Destructuring

Note that `store` is an object wrapped with reactive, meaning there is no need to write `.value` after getters but, like props in setup, we cannot destructure it:

```vue
<script setup>
import { useCounterStore } from '@/stores/counter'
import { computed } from 'vue'

const store = useCounterStore()
// ‚ùå This won't work because it breaks reactivity
// same as reactive: https://vuejs.org/guide/essentials/reactivity-fundamentals.html#limitations-of-reactive
const { name, doubleCount } = store
name // will always be "Eduardo"
doubleCount // will always be 0

setTimeout(() => {
  store.increment()
}, 1000)

// ‚úÖ this one will be reactive
// üí° but you could also just use `store.doubleCount` directly
const doubleValue = computed(() => store.doubleCount)
</script>
```

## üîÑ Destructuring from a Store

In order to extract properties from the store while keeping its reactivity, you need to use `storeToRefs()`. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:

```vue
<script setup>
import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'

const store = useCounterStore()
// `name` and `doubleCount` are reactive refs
// This will also extract refs for properties added by plugins
// but skip any action or non reactive (non ref/reactive) property
const { name, doubleCount } = storeToRefs(store)
// the increment action can just be destructured
const { increment } = store
</script>
```

const { name, doubleCount } = storeToRefs(store)
// the increment action can just be destructured
const { increment } = store
</script>
